{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"反混淆工具de4dot的使用","slug":"反混淆工具de4dot的使用","date":"2023-05-12T08:39:56.000Z","updated":"2023-05-12T09:50:00.563Z","comments":true,"path":"2023/05/12/反混淆工具de4dot的使用/","link":"","permalink":"http://example.com/2023/05/12/%E5%8F%8D%E6%B7%B7%E6%B7%86%E5%B7%A5%E5%85%B7de4dot%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言在之前的文章中我们讲述了如何利用dnSpy反编译.NET程序,但例子过于简单。 在非开源作品中绝大多数都进行了代码混淆,例如以下程序: 这样的代码是难以阅读的,这时候就要用到反混淆工具de4dot de4dot安装de4dot下载-&gt;Click 需要自行编译生成exe文件,解压后根据Visual Studio及SDK版本选择对应sln de4dot.netcore.sln对应.net core2.1及3.1 de4dot.netframework.sln对应.net framework3.5及4.5 进入项目后按F6键后进入以下目录: 1解压文件夹名称\\Debug\\SDK版本文件夹 例:笔者的SDK版本为.net core3.1,exe文件生成路径为: 1temp\\Debug\\netcoreapp3.1 de4dot的使用win+r -&gt; cmd -&gt; cd到exe文件所在路径,执行以下命令: 1de4dot 你要执行反混淆文件的路径 这里以反混淆D:\\TEMP\\Temp.exe为例: 在控制台执行以下命令: 1de4dot D:\\TEMP\\Temp.exe 执行完毕后,TEMP内生成了反混淆后的exe文件 在dnSpy中打开该文件,发现混淆已去除 de4dot扩展使用待续… 后谈反混淆仅用于学习,请勿用于暴力破解商业软件。","categories":[{"name":".NET","slug":"NET","permalink":"http://example.com/categories/NET/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"WPF中的MVVM模式","slug":"WPF中的MVVM模式","date":"2023-05-12T02:39:56.000Z","updated":"2023-05-12T09:03:11.246Z","comments":true,"path":"2023/05/12/WPF中的MVVM模式/","link":"","permalink":"http://example.com/2023/05/12/WPF%E4%B8%AD%E7%9A%84MVVM%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言最近在学习WPF,发现它和Winform差别还蛮大的,前者是数据驱动而后者是事件驱动。 Winform中UI层和代码层几乎是不可分的,一旦UI形式改变代码也必须要进行重写。 而WPF凭借其特性可以通过MVVM模式让数据与UI进行绑定,在UI没有本质改变的情况下重用代码,也就是实现了UI和后端代码的解耦。 本文将介绍如何不使用MVVM框架实现MVVM模式。 INotifyPropertyChanged接口该接口用于通知属性已变更,每个ViewModel都需要继承INotifyPropertyChanged接口,所以可以声明一个通知基类 成员 PropertyChanged事件(委托为PropertyChangedEventHandl) 我们要为其定义一个触发函数 1234567891011public class NotifycationObject : INotifyPropertyChanged &#123; public event PropertyChangedEventHandler PropertyChanged; public void RaisePropertyChange(PropertyChangedEventArgs e) &#123; if (PropertyChanged != null) &#123; PropertyChanged.Invoke(this,e); &#125; &#125; &#125; 当RaisePropertyChange方法被调用时,PropertyChanged事件将被调用,UI控件能够通过该事件监听到数据变化,从而实现界面更新。 ICommand接口该接口用于将控件与行为的解耦 成员 CanExecuteChanged事件(委托为EventHandler) 该事件被触发时,会通知UI当前命令的可执行状态已更改,从而控制UI状态 如果你不想改变命令的可执行状态,可以不 CanExecute方法 根据用户传入的方法情况判断是否可以执行命令 Execute方法 该方法用于执行实际操作,根据用户传入的方法情况进行调用 1234567891011121314151617181920212223242526272829303132public class DelegateCommand : ICommand &#123; public event EventHandler CanExecuteChanged; //要执行的方法 委托类型根据具体方法而定 public Action ExecuteAction &#123; get; set; &#125; //判断是否可以执行的方法 委托类型根据具体方法而定 public Func&lt;object, bool&gt; CanExecuteFunc &#123; get; set; &#125; public DelegateCommand(Action _aciton, Func&lt;object, bool&gt; _func) &#123; ExecuteAction = _aciton; CanExecuteFunc = _func; &#125; public bool CanExecute(object parameter) &#123; if (CanExecuteFunc==null) &#123; return false; &#125; return CanExecuteFunc(parameter); &#125; public void Execute(object parameter) &#123; if (ExecuteAction==null) &#123; return; &#125; ExecuteAction(); &#125; &#125; 在声明ICommand实现类对象时需要传入具体逻辑方法(ExecuteAction)和是否可执行判断方法(CanExecuteFunc) ViewModelViewModel是View和Model的中间层 View:ViewModle&#x3D;1:1 ViewModel:View&#x3D;N:1 ViewModle:Model&#x3D;1:N 在set修饰器中通过调用RaisePropertyChange方法来提醒UI进行数据变化 xaml中绑定AddCommand命令的控件触发命令时会执行Add方法 从而实现双向绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainWindowViewModel:NotifycationObject&#123; private double input1; public double Input1 &#123; get &#123; return input1; &#125; set &#123; input1 = value; RaisePropertyChange(new PropertyChangedEventArgs(&quot;Input1&quot;)); &#125; &#125; private double input2; public double Input2 &#123; get &#123; return input2; &#125; set &#123; input2 = value; RaisePropertyChange(new PropertyChangedEventArgs(&quot;Input2&quot;)); &#125; &#125; private double result; public double Result &#123; get &#123; return result; &#125; set &#123; result = value; RaisePropertyChange(new PropertyChangedEventArgs(&quot;Result&quot;)); &#125; &#125; public DelegateCommand AddCommand &#123; get; set; &#125; private void Add() &#123; Result = Input1 + Input2; &#125; public MainWindowViewModel() &#123; AddCommand = new DelegateCommand(Add,(para)=&gt;true); &#125;&#125; 后谈虽然实现了双向绑定但代码量有点多,抛开UI非本质大改这种情况感觉并没有减少多少工作量,或许利用MVVM框架会更方便？我不知道。","categories":[{"name":".NET","slug":"NET","permalink":"http://example.com/categories/NET/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"http://example.com/tags/WPF/"}]},{"title":"反编译工具dnSpy的使用","slug":"反编译工具dnSpy的使用","date":"2023-05-12T02:39:56.000Z","updated":"2023-05-12T05:00:40.044Z","comments":true,"path":"2023/05/12/反编译工具dnSpy的使用/","link":"","permalink":"http://example.com/2023/05/12/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7dnSpy%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言经常能在论坛看到基于.NET平台框架的实用工具,而这些工具往往是非开源的。 以学习为目的,我们可以通过反编译工具来获取其源码。 如果安装了Visual Studio,则可以在以下路径找到Microsoft官方的反编译工具ildasm 1C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.8 Tools 该工具反编译结果为IL语言,与C#有语法差异,故本文将介绍第三方反编译工具dnSpy的使用 dnSpy安装dnSpy的下载-&gt; Click 下载后解压到任意目录即可 dnSpy使用点击dnSpy.exe启动程序 进入主界面,点击左上角的文件,再点击打开,在弹窗中选择目标文件即可 这里以笔者的控制台文件为例,通过反编译exe文件获取源码 在右键菜单,选择你想要编译的部分,这里以编辑类为例 在弹窗中修改类的内容后点击右下角的编译按钮进行保存 再次右击,选择调试(根据程序类型选择32bit或64bit版本的dnSpy进行调试) 在弹出窗口内选择确认后出现运行结果 后谈实际中还会有加密等情况需要依赖反混淆工具。(de4dot) 反编译仅用于学习,请勿传播未开源项目的反编译结果。","categories":[{"name":".NET","slug":"NET","permalink":"http://example.com/categories/NET/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":".NET","slug":"NET","permalink":"http://example.com/categories/NET/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"WPF","slug":"WPF","permalink":"http://example.com/tags/WPF/"}]}